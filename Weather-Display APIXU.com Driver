/**
 * Custom Weather-Display APIXU.com Driver
 *
 *  Copyright 2018 @Matthew (Scottma61)
 *
 *  This driver was originally written by @Cobra who adapted it from @mattw01's work and I thank them for that!
 *  Heavily modified by myself: @Matthew (Scottma61) with lots of help from the Hubitat community.
 *
 *  This driver is intended to pull data from data files from a web server created by Weather-Display software
 *  (http://www.weather-display.com).  It will also suppliment forecast data from APIXU.COM (APIXU).
 *  You will need your APIXU API key for this.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 *
 *  Last Update 05/25/2018
 * { Left room below to document version changes...}
 *
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  V1.0.0 - Original version 05/25/2018
 *
 */
metadata {
    definition (name: "Weather-Display APIXU Driver", namespace: "Matthew", author: "Scottma61") {
        capability "Actuator"
        capability "Sensor"
        capability "Temperature Measurement"
        capability "Illuminance Measurement"
        capability "Relative Humidity Measurement"
        
        command "ForcePoll"
	
// Weather-Display sourced attributes        
        attribute "dewpoint", "number"
		    attribute "pwsobservation_time", "string"
        attribute "apixuobservation_time", "string"
        attribute "precip_1hr", "number"
        attribute "precip_today", "number"
		    attribute "pressure", "number"
		    attribute "weather", "string"
        attribute "weatherIcon", "string"
        attribute "wind_dir", "string"
        attribute "wind_gust", "string"
        attribute "wind", "number"
		    attribute "city", "string"
		    attribute "feelsLike", "number"	
        attribute "localSunset", "string"
		    attribute "localSunrise", "string"
		    attribute "moonPhase", "string"
        attribute "moonIllumination", "string"
		    attribute "solarradiation", "number"		
        attribute "state", "string"
		    attribute "UV", "number"
	
 // User specified attributes
		    attribute "dateFormat", "string"
        attribute "driverNameSpace", "string"
		    attribute "driverVersion", "string"
        attribute "distanceUnit", "string"
		    attribute "pwspollsSinceReset", "number"
        attribute "apixupollsSinceReset", "number"
        attribute "pressureUnit", "string"
        attribute "rainUnit", "string"
        attribute "summaryFormat", "string"
		    attribute "temperatureUnit", "string"
        attribute "weatherSummary", "string"
        attribute "weatherSummaryFormat", "string"
    }
    preferences() {
        section("Query Inputs"){
        	input "tempFormat", "enum", required: true, title: "Display Unit - Temperature: Fahrenheit or Celsius",  options: ["Fahrenheit", "Celsius"]
			    input "distanceFormat", "enum", required: true, title: "Display Unit - Distance/Speed: Miles or Kilometres",  options: ["Miles (mph)", "Kilometres (kph)"]
			    input "pressureFormat", "enum", required: true, title: "Display Unit - Pressure: Inches or Millibar",  options: ["Inches", "Millibar"]
			    input "rainFormat", "enum", required: true, title: "Display Unit - Precipitation: Inches or Millimetres",  options: ["Inches", "Millimetres"]
			    input "summaryType", "bool", title: "Full Weather Summary", required: true, defaultValue: false
			    input "iconType", "bool", title: "Icon: On = Current - Off = Forecast", required: true, defaultValue: false
			    input "weatherFormat", "enum", required: true, title: "How to format weather summary",  options: ["Celsius, Miles & MPH", "Fahrenheit, Miles & MPH", "Celsius, Kilometres & KPH"]
	    
    			input "pwspollLocation", "text", required: true, title: "PWS Data file location"
    			input "pollIntervalLimit", "number", title: "Poll Interval Limit:", required: true, defaultValue: 1
    			input "autoPoll", "bool", required: false, title: "Enable Auto Poll", defaultValue: false
    			input "pollInterval", "enum", title: "Auto Poll Interval:", required: false, defaultValue: "5 Minutes", options: ["5 Minutes", "10 Minutes", "15 Minutes", "30 Minutes", "1 Hour", "3 Hours"]
    			input "pwslogSet", "bool", title: "Log All PWS Response Data", required: true, defaultValue: false
    			input "cutOff", "time", title: "New Day Starts", required: true
	    
    			input "apixuapiKey", "text", required: true, title: "APIXU API Key"
			    input "apixupollLocation", "text", required: true, title: "Location code for APIXU"
			    input "apixulogSet", "bool", title: "Log All APIXU Response Data", required: true, defaultValue: false
            
          input "sourcecity", "bool", required: true, title: "City from Weather-Display?", defaultValue: true
			    input "sourcefeelsLike", "bool", required: true, title: "FeelsLike from Weather-Display?", defaultValue: true
			    input "sourceIcon", "bool", required: true, title: "Icon from Weather-Display?", defaultValue: true
			    input "sourcelocalSunset", "bool", required: true, title: "Sunrise from Weather-Display?", defaultValue: true
			    input "sourcelocalSunrise", "bool", required: true, title: "Sunset from Weather-Display?", defaultValue: true
			    input "sourcemoonPhase", "bool", required: true, title: "MoonPhase from Weather-Display?", defaultValue: true
			    input "sourcemoonIllumination", "bool", required: true, title: "MoonIllum from Weather-Display?", defaultValue: true
//			    input "sourcesolarradiation", "bool", required: true, title: "SolarRad from Weather-Display?", defaultValue: true
			    input "sourcestate", "bool", required: true, title: "State from Weather-Display?", defaultValue: true
			    input "sourceUV", "bool", required: true, title: "UV from Weather-Display?", defaultValue: true
       }
    }
}

// Poll PWS
def update() {
    log.debug "PWS update called"
    state.version = "1.0.0"    // ************************* Update as required *************************************
    unschedule()
    state.NumOfPolls = 0
    ForcePoll()
    def pollIntervalCmd = (settings?.pollInterval ?: "5 Minutes").replace(" ", "")
    if(autoPoll)
        "runEvery${pollIntervalCmd}"(pollSchedule)
    def changeOver = cutOff
    schedule(changeOver, ResetPollCount)
}

def ResetPollCount(){
	state.NumOfPolls = -1
    	log.info "Poll counter reset.."
	ForcePoll()
}

def pollSchedule(){
    	ForcePoll()
}
              
def parse(String description) {
}

def Poll(){
    if(lastPoll == null){ lastPoll = now() }
    if(pollIntervalLimit == null){ pollIntervalLimit = 0 }
    	if(now() - state.lastPoll > (pollIntervalLimit * 60000))
        	ForcePoll()
    	else
        	log.debug "Poll called before interval threshold was reached"
}
def ForcePoll(){
    if(state.NumOfPolls == null) {
        state.NumOfPolls = 0
    }
	state.NumOfPolls = (state.NumOfPolls) + 1
	log.info " state.NumOfPolls = $state.NumOfPolls" 
    log.debug "ForcePoll called"
    def WeatherSummeryFormat = weatherFormat
	sendEvent(name: "pollsSinceReset", value: state.NumOfPolls, isStateChange: true)
	sendEvent(name: "driverNameSpace", value: "Matthew", isStateChange: true)
	sendEvent(name: "driverVersion", value: state.version, isStateChange: true)
	
	def params1 = [
		uri: "${pwspollLocation}/everything.php"
    	]
    def params2 = [
        uri: "http://api.apixu.com/v1/forecast.json?key=${apixuapiKey}&q=${apixupollLocation}&days=3"
    	]
    	try {
        	httpGet(params1) { resp1 ->
	            	resp1.headers.each {
        	    	log.debug "Response1: ${it.name} : ${it.value}"
        			}
					if(pwslogSet == true){  
						log.debug "params1: ${params1}"
						log.debug "response contentType: ${resp1.contentType}"
						log.debug "response data: ${resp1.data}"
					} 
					if(pwslogSet == false){ 
						log.info "Further PWS detailed data logging disabled"
					}
// Start Weather-Display data poll		
		if(sourcecity){
			sendEvent(name: "city", value: resp1.data.station.name.split(/ /)[0], isStateChange: true)
		}
        if(sourcefeelsLike){
            sendEvent(name: "weatherIcon", value: resp1.data.everything.weather.apparent_temperature.current.f, isStateChange: true)
        }
		if(sourceicon){
			sendEvent(name: "weatherIcon", value: resp1.data.everything.forecast.icon.code, isStateChange: true)
		}
		if(sourcelocalSunset){
			sendEvent(name: "localSunset", value: resp1.data.everything.astronomy.sun.sunset_time.hour + ":" + resp1.data.everything.astronomy.sun.sunset_time.minute, descriptionText: "Sunset today at is $localSunset", isStateChange: true)
		}
		if(sourcelocalSunrise){
			sendEvent(name: "localSunrise", value: resp1.data.everything.astronomy.sun.sunrise_time.hour + ":" + resp1.data.everything.astronomy.sun.sunrise_time.minute, descriptionText: "Sunrise today is at $localSunrise", isStateChange: true)
		}
		if(sourcemoonPhase){
			sendEvent(name: "moonAge", value: resp1.data.everything.astronomy.moon.moon_age.toDouble(), isStateChange: true)
			if (resp1.data.everything.astronomy.moon.moon_age.toDouble() >= 0 && resp1.data.everything.astronomy.moon.moon_age.toDouble() < 4) {sendEvent(name: "moonPhase", value: "New Moon", isStateChange: true)}
			if (resp1.data.everything.astronomy.moon.moon_age.toDouble() >= 4 && resp1.data.everything.astronomy.moon.moon_age.toDouble() < 7) {sendEvent(name: "moonPhase", value: "Waxing Crescent", isStateChange: true)}
			if (resp1.data.everything.astronomy.moon.moon_age.toDouble() >= 7 && resp1.data.everything.astronomy.moon.moon_age.toDouble() < 10) {sendEvent(name: "moonPhase", value: "First Quarter", isStateChange: true)}
			if (resp1.data.everything.astronomy.moon.moon_age.toDouble() >= 10 && resp1.data.everything.astronomy.moon.moon_age.toDouble() < 14) {sendEvent(name: "moonPhase", value: "Waxing Gibbous", isStateChange: true)}
			if (resp1.data.everything.astronomy.moon.moon_age.toDouble() >= 14 && resp1.data.everything.astronomy.moon.moon_age.toDouble() < 18) {sendEvent(name: "moonPhase", value: "Full Moon", isStateChange: true)}
			if (resp1.data.everything.astronomy.moon.moon_age.toDouble() >= 18 && resp1.data.everything.astronomy.moon.moon_age.toDouble() < 22) {sendEvent(name: "moonPhase", value: "Waning Gibbous", isStateChange: true)}
			if (resp1.data.everything.astronomy.moon.moon_age.toDouble() >= 22 && resp1.data.everything.astronomy.moon.moon_age.toDouble() < 26) {sendEvent(name: "moonPhase", value: "Last Quarter", isStateChange: true)}
			if (resp1.data.everything.astronomy.moon.moon_age.toDouble() >= 26) {sendEvent(name: "moonPhase", value: "Waxing Gibbous", isStateChange: true)}
		}
		if(sourcemoonIllumination){
			sendEvent(name: "moonIllumination", value: resp1.data.everything.astronomy.moon.moon_phase + "%", isStateChange: true)
		}
		def illume = (resp1.data.everything.weather.solar.irradiance.wm2)
		if(sourcesolarradiation){
			if(illume){
				 sendEvent(name: "illuminance", value: resp1.data.everything.weather.solar.irradiance.wm2, unit: "lux", isStateChange: true)
				 sendEvent(name: "solarradiation", value: resp1.data.everything.weather.solar.irradiance.wm2, unit: "wm2", isStateChange: true)
			}
			if(!illume){
				sendEvent(name: "illuminance", value: "This station does not send Illumination data", isStateChange: true)
			 	sendEvent(name: "solarradiation", value: "This station does not send Solar Radiation data", isStateChange: true)
			}   
		}
		if(sourcestate){
			sendEvent(name: "state", value: resp1.data.station.name.split(/ /)[1], isStateChange: true)
		}
		if(sourceUV){
			sendEvent(name: "UV", value: resp1.data.everything.weather.uv.uvi, isStateChange: true)
		}
		sendEvent(name: "weather", value: resp1.data.everything.forecast.davis_forecast, isStateChange: true)
		sendEvent(name: "humidity", value: resp1.data.everything.weather.humidity.current, isStateChange: true)
		if(iconType == true){ 
		   sendEvent(name: "weatherIcon", value: resp1.data.everything.forecast.icon.code, isStateChange: true)
		}    
        sendEvent(name: "pwsobservation_time", value: "Last updated on "  + Date.parse("d/M/yyyy", resp1.data.time.date).format("MMMM d,") + " " + Date.parse("hh:mm", resp1.data.time.time).format("h:mm a"), isStateChange: true)
		sendEvent(name: "wind_dir", value: resp1.data.everything.weather.wind.direction.cardinal, isStateChange: true)
		if(rainFormat == "Inches"){
			sendEvent(name: "precip_today", value: resp1.data.everything.weather.rainfall.daily.in, unit: "IN", isStateChange: true)
			sendEvent(name: "rainUnit", value: "Inches", isStateChange: true)
		}
		if(rainFormat == "Millimetres"){   
			sendEvent(name: "precip_today", value: resp1.everything.weather.data.rainfall.daily.mm, unit: "MM", isStateChange: true)
			sendEvent(name: "rainUnit", value: "Millimetres", isStateChange: true)
		}
		if(tempFormat == "Celsius"){
			sendEvent(name: "dewpoint", value: resp1.data.everything.weather.dew_point.current.c, unit: "C", isStateChange: true)
			sendEvent(name: "temperatureUnit", value: "Celsius", isStateChange: true)
			sendEvent(name: "temperature", value: resp1.data.everything.weather.temperature.current.c, unit: "C", isStateChange: true)   	
		}
		if(tempFormat == "Fahrenheit"){ 
			sendEvent(name: "dewpoint", value: resp1.data.everything.weather.dew_point.current.f, unit: "F", isStateChange: true)
			sendEvent(name: "temperatureUnit", value: "Fahrenheit", isStateChange: true)
			sendEvent(name: "temperature", value: resp1.data.everything.weather.temperature.current.f, unit: "F", isStateChange: true)    	
		}  
	   	if(distanceFormat == "Miles (mph)"){  
			sendEvent(name: "wind", value: resp1.data.everything.weather.wind.avg_speed.mph, unit: "MPH", isStateChange: true)
	   		sendEvent(name: "wind_gust", value: resp1.data.everything.weather.wind.max_gust_speed.mph, isStateChange: true) 
	   		sendEvent(name: "distanceUnit", value: "Miles (mph)", isStateChange: true)
	   	}  
	   	if(distanceFormat == "Kilometres (kph)"){
			sendEvent(name: "wind", value: resp1.data.everything.weather.wind.max_gust_speed.kmh, unit: "KPH", isStateChange: true)  
			sendEvent(name: "wind_gust", value: resp1.data.everything.weather.wind.max_gust_speed.kmh, isStateChange: true) 
			sendEvent(name: "distanceUnit", value: "Kilometres (kph)", isStateChange: true)  
	   	}		  
	   	if(pressureFormat == "Inches"){
			sendEvent(name: "pressure", value: resp1.data.everything.weather.pressure.current.inhg, unit: "inhg", isStateChange: true)
			sendEvent(name: "pressureUnit", value: "Inches")  
	   	}
		if(pressureFormat == "Millibar"){
			sendEvent(name: "pressure", value: resp1.data.everything.weather.pressure.current.mb, unit: "mb", isStateChange: true)
		   	sendEvent(name: "pressureUnit", value: "Millibar", isStateChange: true) 
	   	}
// end PWS data poll		Start APIXI.com data poll
            httpGet(params2) { resp2 ->
	            	resp2.headers.each {
        	    	log.debug "Response2: ${it.name} : ${it.value}"
			}
			if(apixulogSet == true){  
			    log.debug "params2: ${params2}"
			    log.debug "response contentType: ${resp2.contentType}"
			    log.debug "response data: ${resp2.data}"
			} 
			if(apixulogSet == false){ 
				log.info "Further APIXU detailed data logging disabled"
			}
		if(!sourcecity){
			sendEvent(name: "city", value: resp2.data.location.name, isStateChange: true)
		}
		if(!sourceicon){
			if(iconType == false){   
                sendEvent(name: "weatherIcon", value: "http:" + resp2.data.forecast.forecastday[0].day.condition.icon, isStateChange: true)
                	}
                	if(iconType == true){ 
			       sendEvent(name: "weatherIcon", value: resp2.data.current.condition.icon, isStateChange: true)
                	}
		}
		if(!sourcelocalSunset){
			sendEvent(name: "localSunset", value: resp2.data.forecast.forecastday[0].astro.sunset, descriptionText: "Sunset today at is $localSunset", isStateChange: true)
		}
		if(!sourcelocalSunrise){
			sendEvent(name: "localSunrise", value: resp2.data.forecast.forecastday[0].astro.sunrise, descriptionText: "Sunrise today is at $localSunrise", isStateChange: true)
		}
		if(!sourcemoonPhase){
			sendEvent(name: "moonPhase", value: resp2.data.forecast.forecastday[0].astro.moon_phase , isStateChange: true)
		}
		if(!sourcemoonIllumination){
			sendEvent(name: "moonIllumination", value: resp2.forecast.forecastday[0].astro.moon_illumination  + "%" , isStateChange: true)
		}
/*		if(!sourcesolarradiation){
        		if(illume){
            	 		sendEvent(name: "illuminance", value: resp2.data.current_observation.solarradiation, unit: "lux", isStateChange: true)
                 		sendEvent(name: "solarradiation", value: resp2.data.current_observation.solarradiation, unit: "W", isStateChange: true)
            		}
            		if(!illume){
                 		sendEvent(name: "illuminance", value: "This station does not send Illumination data", isStateChange: true)
            	 		sendEvent(name: "solarradiation", value: "This station does not send Solar Radiation data", isStateChange: true)
            		}
		}
*/		if(!sourcestate){
			sendEvent(name: "state", value: resp2.data.location.region, isStateChange: true)
		}
		if(!sourceUV){
			sendEvent(name: "UV", value: resp2.data.forecast.forecastday[0].day.uv, isStateChange: true)
		}

		sendEvent(name: "stationID", value: resp2.data.location.name + ", " + resp2.data.location.region, isStateChange: true)
//	  sendEvent(name: "chanceOfRain", value: resp2.data.forecast.forecastday[0].hour.chance_of_rain + "%", isStateChange: true)
//		sendEvent(name: "percentPrecip", value: resp2.data.forecast.forecastday.date.todaycast.chance_of_rain , isStateChange: true)
		sendEvent(name: "forecastConditions", value: resp2.data.forecast.forecastday[0].day.condition.text, isStateChange: true)            
		if(rainFormat == "Inches"){
			sendEvent(name: "rainTomorrow", value: resp2.data.forecast.forecastday[1].day.totalprecip_in, isStateChange: true)
			sendEvent(name: "rainDayAfterTomorrow", value: resp2.data.forecast.forecastday[2].day.totalprecip_in, unit: "IN", isStateChange: true)
		}
		if(rainFormat == "Millimetres"){   
			sendEvent(name: "rainTomorrow", value: resp2.data.forecast.forecastday[1].day.totalprecip_mm, unit: "MM", isStateChange: true)
			sendEvent(name: "rainDayAfterTomorrow", value: resp2.data.forecast.forecastday[2].day.totalprecip_mm, unit: "MM", isStateChange: true)
		}		
		sendEvent(name: "apixuobservation_time", value: Date.parse("yyyy-MM-dd hh:mm", resp2.data.current.last_updated).format("MMMM d,") + " " + Date.parse("yyyy-MM-dd hh:mm", resp2.data.current.last_updated).format("h:mm a"), isStateChange: true)
	   	sendEvent(name: "forecastConditions", value: resp2.data.forecast.forecastday[0].day.condition.text, isStateChange: true)
	   	if(tempFormat == "Fahrenheit"){ 
			if(!sourcefeelsLike){
				sendEvent(name: "feelsLike", value: resp2.data.current.feelslike_f, unit: "F", isStateChange: true)
            }
			sendEvent(name: "forecastHigh", value: resp2.data.forecast.forecastday[0].day.maxtemp_f, unit: "F", isStateChange: true)
			sendEvent(name: "forecastLow", value: resp2.data.forecast.forecastday[0].day.mintemp_f, unit: "F", isStateChange: true)
		}
		if(tempFormat == "Celsius"){
			if(!sourcefeelsLike){
				sendEvent(name: "feelsLike", value: resp2.data.current.feelslike_c, unit: "C", isStateChange: true)
            }
			sendEvent(name: "forecastHigh", value: resp2.data.forecast.forecastday[0].day.maxtemp_c, unit: "F", isStateChange: true)
			sendEvent(name: "forecastLow", value: resp2.data.forecast.forecastday[0].day.mintemp_c, unit: "F", isStateChange: true)
		}
		if(distanceFormat == "Miles (mph)"){  
			sendEvent(name: "visibility", value: resp2.data.current.vis_miles, unit: "mi", isStateChange: true)
            sendEvent(name: "wind_string", value: "Wind is from " + resp2.data.current.wind_dir + " at " +resp2.data.current.wind_mph + " MPH", isStateChange: true)
		}
		if(distanceFormat == "Kilometres (kph)"){
			sendEvent(name: "visibility", value: resp2.data.current.vis_km, unit: "km", isStateChange: true)
            sendEvent(name: "wind_string", value: "Wind is from " + resp2.data.current.wind_dir + " at " +resp2.data.current.wind_kph + " KPH", isStateChange: true)
		}
          
		if(summaryType == true){
			if (WeatherSummeryFormat == "Celsius, Miles & MPH"){
	   		sendEvent(name: "weatherSummaryFormat", value: "Celsius, Miles & MPH", isStateChange: true)
				sendEvent(name: "weatherSummary", value: "Weather summary for" + " " + resp1.data.station.name.split(/ /)[0] + ", " + resp1.data.station.name.split(/ /)[1] 
                + " updated at " + Date.parse("hh:mm", resp1.data.time.time).format("h:mm a") + " on " + Date.parse("d/M/yyyy", resp1.data.time.date).format("MMMM d") + ". "  
				+ resp2.data.forecast.forecastday[0].day.condition.text + " with a high of " + resp2.data.forecast.forecastday[0].day.maxtemp_c + " degrees, " + "and a low of " 
				+ resp2.data.forecast.forecastday[0].day.mintemp_c  + " degrees. " + "Humidity is currently around " + resp1.data.everything.weather.humidity.current + "% and temperature is " 
				+ resp1.data.everything.weather.temperature.current.c + " degrees. " + " The temperature feels like it's " + resp2.data.current.feelslike_c + " degrees. " 
				+ "Wind is from the " + resp1.data.everything.weather.wind.direction.cardinal
				+ " at " + resp1.data.everything.weather.wind.avg_speed.mph + " mph" + ", with gusts up to " + resp1.data.everything.weather.wind.max_gust_speed.mph + " mph" + ". Visibility is around " 
				+ resp2.data.current.vis_miles + " miles" + "." , isStateChange: true
				)  
			}
			if (WeatherSummeryFormat == "Fahrenheit, Miles & MPH"){
				sendEvent(name: "weatherSummaryFormat", value: "Fahrenheit, Miles & MPH", isStateChange: true)
				sendEvent(name: "weatherSummary", value: "Weather summary for" + " " + resp1.data.station.name.split(/ /)[0] + ", " + resp1.data.station.name.split(/ /)[1] 
                + " updated at " + Date.parse("hh:mm", resp1.data.time.time).format("h:mm a") + " on " + Date.parse("d/M/yyyy", resp1.data.time.date).format("MMMM d") + ". "  
				+ resp2.data.forecast.forecastday[0].day.condition.text + " with a high of " + resp2.data.forecast.forecastday[0].day.maxtemp_f + " degrees, " + "and a low of " 
				+ resp2.data.forecast.forecastday[0].day.mintemp_f  + " degrees. " + "Humidity is currently around " + resp1.data.everything.weather.humidity.current + "% and temperature is " 
				+ resp1.data.everything.weather.temperature.current.f + " degrees. " + " The temperature feels like it's " + resp2.data.current.feelslike_f + " degrees. " 
				+ "Wind is from the " + resp1.data.everything.weather.wind.direction.cardinal
				+ " at " + resp1.data.everything.weather.wind.avg_speed.mph + " mph" + ", with gusts up to " + resp1.data.everything.weather.wind.max_gust_speed.mph + " mph" + ". Visibility is around " 
				+ resp2.data.current.vis_miles + " miles" + ".", isStateChange: true
				)  
			}   
			 if (WeatherSummeryFormat == "Celsius, Kilometres & KPH"){
				sendEvent(name: "weatherSummaryFormat", value: "Celsius, Kilometres & KPH", isStateChange: true)
				sendEvent(name: "weatherSummary", value: "Weather summary for" + " " + resp1.data.station.name.split(/ /)[0] + ", " + resp1.data.station.name.split(/ /)[1] 
        + " updated at " + Date.parse("hh:mm", resp1.data.time.time).format("h:mm a") + " on " + Date.parse("d/M/yyyy", resp1.data.time.date).format("MMMM d") + ". "  
				+ resp2.data.forecast.forecastday[0].day.condition.text + " with a high of " + resp2.data.forecast.forecastday[0].day.maxtemp_c + " degrees, " + "and a low of " 
				+ resp2.data.forecast.forecastday[0].day.mintemp_c  + " degrees. " + "Humidity is currently around " + resp1.data.everything.weather.humidity.current + "% and temperature is " 
				+ resp1.data.everything.weather.temperature.current.c + " degrees. " + " The temperature feels like it's " + resp2.data.current.feelslike_c + " degrees. " 
				+ "Wind is from the " + resp1.data.everything.weather.wind.direction.cardinal
				+ " at " + resp1.data.everything.weather.wind.avg_speed.kmh + " kph" + ", with gusts up to " + resp1.data.everything.weather.wind.max_gust_speed.kmh + " kph" + ". Visibility is around " 
				+ resp2.data.current.vis_km + " kilometers.", isStateChange: true
				)  
			}                
		}    
		if(summaryType == false){
			if (WeatherSummeryFormat == "Celsius, Miles & MPH"){
		 		sendEvent(name: "weatherSummaryFormat", value: "Celsius, Miles & MPH", isStateChange: true)
				sendEvent(name: "weatherSummary", value: resp1.data.everything.forecast.davis_forecast + ". " + " Today's High:" + resp1.data.everything.weather.temperature.current.high.c + ", Today's Low:" 
				+ resp1.data.everything.weather.tempurature.current.low.c  +  ". Humidity: " + resp1.data.everything.weather.current.humidity + "% Temperature: " 
				+ resp1.data.everything.weather.tempurature.current.c  + ". Wind Direction: " + resp1.data.everything.weather.wind.direction.cardinal + ". Wind Speed: " + resp1.data.everything.weather.avg_speed.mph + " mph" 
				+ ", Gust: " + resp1.data.everything.weather.max_gust_speed.mph + " mph.", isStateChange: true
				)  
			}
			if (WeatherSummeryFormat == "Fahrenheit, Miles & MPH"){
				sendEvent(name: "weatherSummaryFormat", value: "Fahrenheit, Miles & MPH", isStateChange: true)
				sendEvent(name: "weatherSummary", value: resp1.data.everything.forecast.davis_forecast + ". " + " Today's High:" + resp1.data.everything.weather.temperature.current.high.f + ", Today's Low:" 
				+ resp1.data.everything.weather.tempurature.current.low.f  +  ". Humidity: " + resp1.data.everything.weather.current.humidity + "% Temperature: " 
				+ resp1.data.everything.weather.tempurature.current.f  + ". Wind Direction: " + resp1.data.everything.weather.wind.direction.cardinal + ". Wind Speed: " + resp1.data.everything.weather.avg_speed.mph + " mph" 
				+ ", Gust: " + resp1.data.everything.weather.max_gust_speed.mph + " mph.", isStateChange: true
				)  
			}
			 if (WeatherSummeryFormat ==  "Celsius, Kilometres & KPH"){
				sendEvent(name: "weatherSummaryFormat", value:  "Celsius, Kilometres & KPH", isStateChange: true)
				sendEvent(name: "weatherSummary", value: resp1.data.everything.forecast.davis_forecast + ". " + " Today's High:" + resp1.data.everything.weather.temperature.current.high.c + ", Today's Low:" 
				+ resp1.data.everything.weather.tempurature.current.low.c  +  ". Humidity: " + resp1.data.everything.weather.current.humidity + "% Temperature: " 
				+ resp1.data.everything.weather.tempurature.current.c  + ". Wind Direction: " + resp1.data.everything.weather.wind.direction.cardinal + ". Wind Speed: " + resp1.data.everything.weather.avg_speed.kmh + " kph" 
				+ ", Gust: " + resp1.data.everything.weather.max_gust_speed.kmh + " kph.", isStateChange: true
				)  
			}
		}                     
/*
        def possAlert = (resp2.data.alerts.description)
		if (possAlert){
        	sendEvent(name: "alert", value: resp2.data.alerts.description, isStateChange: true)  
        }
        if (!possAlert){
            sendEvent(name: "alert", value: " No current weather alerts for this area")
        }
*/        state.apixulastPoll = now()             
	}
            }}	catch (e) {
        log.error "something went wrong: $e"
    }
}
def Report(){
  def pwsobvTime = pwsobservation_time.value
  log.info "PWS last updated: $pwsobvTime"
  def apixuobvTime = apixuobservation_time.value
  log.info "APIXU last updated: $apixuobvTime"  
}
