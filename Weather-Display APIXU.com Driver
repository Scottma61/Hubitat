/*
 * Custom Weather-Display APIXU.com Driver
 *
 *  Copyright 2018 @Matthew (Scottma61)
 *
 *  Many people contributed to the creation of this driver.  Significant contributors include
 *  @Cobra who adapted it from @mattw01's work and I thank them for that!  A large 'Thank you' 
 *  to @bangali for his APIXU.COM base code that some of this was adapted from.  I learned a lot
 *  from his work and incorporated a lot of that here.  With all of that collaboration I have heavily
 *  modified the code myself: @Matthew (Scottma61) with lots of help from the Hubitat community.
 *
 *  This driver is intended to pull data from data files from a web server created by Weather-Display software
 *  (http://www.weather-display.com).  It will also suppliment forecast data from APIXU.COM (XU)
 *  (http://www.apixu.com). You will need your APIXU API key for this.
 *
 *  There are three main sets of weather variables.  The prefix 'wd' is for Weather-Display variabes.  The
 *  prefix 'xu' are fore APIXU variables.  No prefix are for what you can use a 'defaults' based on
 *  your selections in the driver.  These are redundant, but are intended to prevent you from changing your 
 *  variable name to select the data you want.  The driver exposes both metric and imperial measurements and
 *  the full compliment of Weather-Display and APIXU (free version) data are available, so pick what you wish.

 *  The driver has some options to allow you to choose to use the Weather-Display variable or the
 *  APIXU variable where both exist. So, if you have a solar radiation sensor you can choose
 *  to use your own reading, or if you do not have sensor your can choose a APIXU station that does and pull
 *  it's solar radiation reading. There are a handful of variables you can select with this option.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 *
 *  Last Update 05/27/2018
 * { Left room below to document version changes...}
 *
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  V1.1.0 - Major re-write incorporating @bangali's work. 05-27-2018
 *  V1.0.0 - Original version 05/25/2018
 *
 */
metadata {
    definition (name: "Weather-Display APIXU Driver", namespace: "Matthew", author: "Scottma61") {
        capability "Actuator"
        capability "Sensor"
        capability "Temperature Measurement"
        capability "Illuminance Measurement"
        capability "Relative Humidity Measurement"
        
        command "poll"
        command "refresh"
	
// APIXU Sourced Variables
        attribute "alast_updated", "string"
        attribute "aname", "string"
		attribute "aregion", "string"
        attribute "acountry", "string"
        attribute "alocation", "string"
        attribute "alat", "string"
        attribute "alon", "string"
        attribute "atz_id", "string"
        attribute "alocaltime_epoch", "string"
        attribute "alocal_time", "string"
        attribute "alocal_date", "string"
        attribute "alast_updated_epoch", "string"
        attribute "atemp_c", "string"
        attribute "atemp_f", "string"
        attribute "ais_day", "string"
        attribute "acondition_text", "string"
        attribute "acondition_icon", "string"
        attribute "acondition_code", "string"
        attribute "awind_mph", "string"
        attribute "awind_kph", "string"
        attribute "awind_gust_mph", "string"
        attribute "awind_gust_kph", "string"
        attribute "awind_degree", "string"
        attribute "awind_dir", "string"
        attribute "apressure_mb", "string"
        attribute "apressure_in", "string"
        attribute "aprecip_mm", "string"
        attribute "aprecip_in", "string"
        attribute "acloud", "string"
        attribute "afeelslike_c", "string"
        attribute "afeelslike_f", "string"
        attribute "avis_km", "string"
        attribute "avis_miles", "string"
        attribute "adewpoint", "number"
        attribute "aprecip_1hr_in", "number"
        attribute "aprecip_1hr_mm", "number"        
        attribute "aprecip_today_in", "number"
        attribute "aprecip_today_mm", "number"        
		attribute "aUV", "number"

// Weather-Display Sourced Variables
        attribute "wlast_updated", "string"
        attribute "wstationID", "string"
        attribute "wregion", "string"
        attribute "wcountry", "string"
        attribute "wlocation", "string"
        attribute "wtemp_c", "string"
        attribute "wtemp_f", "string"
        attribute "wcondition_text", "string"
        attribute "wcondition_icon", "string"
        attribute "wwind_mph", "string"
        attribute "wwind_kph", "string"
        attribute "wwind_gust_mph", "string"
        attribute "wwind_gust_kph", "string"
        attribute "wwind_degree", "string"
        attribute "wwind_dir", "string"
        attribute "wpressure_mb", "string"
        attribute "wpressure_in", "string"
        attribute "wprecip_mm", "string"
        attribute "wprecip_in", "string"
        attribute "wfeelslike_c", "string"
        attribute "wfeelslike_f", "string"
        attribute "wvis_km", "string"
        attribute "wvis_miles", "string"
        attribute "wdewpoint", "number"        
        attribute "wprecip_today_in", "number"
        attribute "wprecip_today_mm", "number"        
        attribute "wmoonPhase", "string"
        attribute "wmoonIllumination", "string"
        attribute "wsolarradiation", "number"
		attribute "wUV", "number"
		
// SunriseSunSet Sourced variables
        attribute "local_sunrise", "string"
        attribute "local_sunset", "string"
        attribute "twilight_begin", "string"
        attribute "twilight_end", "string"
        
// User specified attributes
        attribute "dateFormat", "string"
        attribute "driverNameSpace", "string"
        attribute "driverVersion", "string"
        attribute "distanceUnit", "string"
        attribute "pressureUnit", "string"
        attribute "rainUnit", "string"
        attribute "temperatureUnit", "string"
        attribute "weatherSummary", "string"
    }
    preferences() {
        section("Query Inputs"){
	    	input "tempFormat", "enum", required: true, defaultValue: "Fahrenheit", title: "Display Unit - Temperature: Fahrenheit or Celsius",  options: ["Fahrenheit", "Celsius"]
            input "distanceFormat", "enum", required: true, defaultValue: "Miles (mph)", title: "Display Unit - Distance/Speed: Miles or Kilometres",  options: ["Miles (mph)", "Kilometers (kph)"]
            input "pressureFormat", "enum", required: true, defaultValue: "Inches", title: "Display Unit - Pressure: Inches or Millibar",  options: ["Inches", "Millibar"]
            input "rainFormat", "enum", required: true, defaultValue: "Inches", title: "Display Unit - Precipitation: Inches or Millimetres",  options: ["Inches", "Millimetres"]
            input "summaryType", "bool", title: "Full Weather Summary", required: true, defaultValue: false
            input "iconType", "bool", title: "Icon: On = Current - Off = Forecast", required: true, defaultValue: false
            input "weatherFormat", "enum", required: true, defaultValue: "Fahrenheit, Miles & MPH", title: "How to format weather summary",  options: ["Celsius, Miles & MPH", "Fahrenheit, Miles & MPH", "Celsius, Kilometres & KPH"]
	    
	    	input "autoPoll", "bool", required: true, title: "Enable Auto Poll", defaultValue: false
            input "pollInterval", "enum", title: "Auto Poll Interval:", required: true, defaultValue: "5 Minutes", options: [05:"5 Minutes", 10:"10 Minutes", 15:"15 Minutes", 30:"30 Minutes", 1:"1 Hour", 3:"3 Hours"]
	    
            input "wdpollLocation", "text", required: true, title: "Weather-Display Data file location", defaultValue: "http://"
            input "wdlogSet", "bool", required: true, title: "Display WD data in log", defaultValue: false            
	    
            input "xuapiKey", "text", required: true, title: "APIXU API Key"
            input "xupollLocation", "text", required: true, title: "Location code for APIXU"
            input "xulogSet", "bool", required: true, title: "Display APIXU data in log", defaultValue: false            
            
            input "sourcecity", "bool", required: true, title: "City from Weather-Display?", defaultValue: true
            input "sourcefeelsLike", "bool", required: true, title: "FeelsLike from Weather-Display?", defaultValue: true
            input "sourceIcon", "bool", required: true, title: "Icon from Weather-Display?", defaultValue: true
            input "sourcelocalSunset", "bool", required: true, title: "Sunrise from Weather-Display?", defaultValue: true
            input "sourcelocalSunrise", "bool", required: true, title: "Sunset from Weather-Display?", defaultValue: true
		    input "sourceIllumination", "bool", required: true, title: "Illume from Weather-Display?", defaultValue: true
            input "sourcestate", "bool", required: true, title: "State from Weather-Display?", defaultValue: true
            input "sourceUV", "bool", required: true, title: "UV from Weather-Display?", defaultValue: true
       }
    }
}

def updated() {
    state.version = "1.1.0"    // ************************* Update as required *************************************
    unschedule()
    state.tz = null
    def pollIntervalCmd = (settings?.pollInterval).toInteger()
    log.debug "pollIntervalCmd: $pollIntervalCmd"
    if(autoPoll){
        if(pollIntervalCmd < 5 ) {  // interval is in hours
            schedule("3 * 0/${pollIntervalCmd} * * ?", "pollSchedule")
        } else {  // interval is in minutes
            schedule("3 0/${pollIntervalCmd} * * * ?", "pollSchedule")
        }
    }
    poll()
}

def pollSchedule(){
    poll()
}
              
def parse(String description) {
}

def poll(){
    log.debug "apixu: Executing 'poll', location: ${location.name}"
    def xu = getXUdata()
    if (!xu)   {
        log.warn "No response from ApiXU API"
        return;
    }

    log.debug "Weather-Display: Executing 'poll', location: ${location.name}"
    def wd = getWDdata()
    if (!wd)   {
        log.warn "No response from Weather-Display API"
        return;
	}

// APIXU   [location:[name:Kolkata, region:West Bengal, country:India, lat:22.57, lon:88.37, tz_id:Asia/Kolkata, localtime_epoch:1526751861, localtime:2018-05-19 23:14], current:[last_updated_epoch:1526751017, last_updated:2018-05-19 23:00, temp_c:28.0, temp_f:82.4, is_day:0, condition:[text:Mist, icon://cdn.apixu.com/weather/64x64/night/143.png, code:1030], wind_mph:10.5, wind_kph:16.9, wind_degree:180, wind_dir:S, pressure_mb:1004.0, pressure_in:30.1, precip_mm:0.0, precip_in:0.0, humidity:84, cloud:25, feelslike_c:33.0, feelslike_f:91.4, vis_km:3.0, vis_miles:1.0], forecast:[forecastday:[[date:2018-05-19, date_epoch:1526688000, day:[maxtemp_c:39.3, maxtemp_f:102.7, mintemp_c:28.6, mintemp_f:83.5, avgtemp_c:32.3, avgtemp_f:90.1, maxwind_mph:15.4, maxwind_kph:24.8, totalprecip_mm:0.0, totalprecip_in:0.0, avgvis_km:16.5, avgvis_miles:10.0, avghumidity:65.0, condition:[text:Thundery outbreaks possible, icon://cdn.apixu.com/weather/64x64/day/200.png, code:1087], uv:11.6], astro:[sunrise:04:55 AM, sunset:06:11 PM, moonrise:08:30 AM, moonset:10:13 PM]], [date:2018-05-20, date_epoch:1526774400, day:[maxtemp_c:41.0, maxtemp_f:105.8, mintemp_c:29.3, mintemp_f:84.7, avgtemp_c:33.4, avgtemp_f:92.1, maxwind_mph:21.9, maxwind_kph:35.3, totalprecip_mm:0.0, totalprecip_in:0.0, avgvis_km:19.2, avgvis_miles:11.0, avghumidity:54.0, condition:[text:Partly cloudy, icon://cdn.apixu.com/weather/64x64/day/116.png, code:1003], uv:11.4], astro:[sunrise:04:54 AM, sunset:06:12 PM, moonrise:09:34 AM, moonset:11:07 PM]], [date:2018-05-21, date_epoch:1526860800, day:[maxtemp_c:38.5, maxtemp_f:101.3, mintemp_c:28.6, mintemp_f:83.5, avgtemp_c:32.9, avgtemp_f:91.2, maxwind_mph:18.3, maxwind_kph:29.5, totalprecip_mm:0.0, totalprecip_in:0.0, avgvis_km:19.9, avgvis_miles:12.0, avghumidity:58.0, condition:[text:Partly cloudy, icon://cdn.apixu.com/weather/64x64/day/116.png, code:1003], uv:10.3], astro:[sunrise:04:54 AM, sunset:06:12 PM, moonrise:10:36 AM, moonset:11:57 PM]]]]]

// Sunrise-Sunset   [results:[sunrise:2018-05-18T23:24:30+00:00, sunset:2018-05-19T12:41:31+00:00, solar_noon:2018-05-19T06:03:00+00:00, day_length:47821, civil_twilight_begin:2018-05-18T23:00:12+00:00, civil_twilight_end:2018-05-19T13:05:48+00:00, nautical_twilight_begin:2018-05-18T22:31:16+00:00, nautical_twilight_end:2018-05-19T13:34:44+00:00, astronomical_twilight_begin:2018-05-18T22:01:24+00:00, astronomical_twilight_end:2018-05-19T14:04:37+00:00], status:OK]
    def isFahrenheit = tempFormat == "Fahrenheit" ? true : false
    def isDistanceMetric = distanceFormat == "Kilometers (kph)" ? true : false
    def isRainMetric = rainFormat == "Millimetres" ? true : false
    def isPressureMetric = pressureFormat == "Millibar" ? true : false
    
    def xunow = new Date().format('MM-dd-yyyy h:mm a', location.timeZone)
    sendEvent(name: "lastXUupdate", value: xunow)

    def tZ = TimeZone.getTimeZone(xu.location.tz_id)
    state.tz = xu.location.tz_id

    def localTime = new Date().parse("yyyy-MM-dd HH:mm", xu.location.localtime, tZ)    
    def localDate = localTime.format("yyyy-MM-dd", tZ)
    def localTimeOnly = localTime.format("HH:mm", tZ)
    def sunriseAndSunset = getSunriseAndSunset(xu.location.lat, xu.location.lon, localDate)

    def sunriseTime = new Date().parse("yyyy-MM-dd'T'HH:mm:ssXXX", sunriseAndSunset.results.sunrise, tZ)
    def sunsetTime = new Date().parse("yyyy-MM-dd'T'HH:mm:ssXXX", sunriseAndSunset.results.sunset, tZ)
    def noonTime = new Date().parse("yyyy-MM-dd'T'HH:mm:ssXXX", sunriseAndSunset.results.solar_noon, tZ)    
    def twilight_begin = new Date().parse("yyyy-MM-dd'T'HH:mm:ssXXX", sunriseAndSunset.results.civil_twilight_begin, tZ)
    def twilight_end = new Date().parse("yyyy-MM-dd'T'HH:mm:ssXXX", sunriseAndSunset.results.civil_twilight_end, tZ)
    
    def slocalSunrise = sunriseTime.format("HH:mm", tZ)
    sendEvent(name: "slocal_sunrise", value: slocalSunrise, descriptionText: "Sunrise today is at $slocalSunrise")
    def slocalSunset = sunsetTime.format("HH:mm", tZ)
    sendEvent(name: "slocal_sunset", value: slocalSunset, descriptionText: "Sunset today at is $slocalSunset")
    def tB = twilight_begin.format("HH:mm", tZ)
    sendEvent(name: "twilight_begin", value: tB, descriptionText: "Twilight begins today at $tB")
    def tE = twilight_end.format("HH:mm", tZ)
    sendEvent(name: "twilight_end", value: tE, descriptionText: "Twilight ends today at $tE")
    sendEvent(name: "driverNameSpace", value: "Matthew", isStateChange: true)
    sendEvent(name: "driverVersion", value: state.version, isStateChange: true)

    sendEvent(name: "xucity", value: xu.location.name, isStateChange: true)
    sendEvent(name: "xustate", value: xu.location.region, isStateChange: true)
    sendEvent(name: "xulocation", value: xu.location.name + ', ' + xu.location.region, isStateChange: true)
    sendEvent(name: "xucountry", value: xu.location.country, isStateChange: true)
    sendEvent(name: "xulat", value: xu.location.lat, isStateChange: true)
    sendEvent(name: "xulon", value: xu.location.lon, isStateChange: true)
    sendEvent(name: "xutz_id", value: xu.location.tz_id, isStateChange: true)
    sendEvent(name: "xulocaltime_epoch", value: xu.location.localtime_epoch, isStateChange: true)
    sendEvent(name: "xulocal_time", value: localTimeOnly, isStateChange: true)
    sendEvent(name: "xulocal_date", value: localDate, isStateChange: true)
    sendEvent(name: "xulast_updated_epoch", value: xu.current.last_updated_epoch, isStateChange: true)
    sendEvent(name: "xulast_updated", value: xu.current.last_updated, isStateChange: true)
    sendEvent(name: "xulocalSunset", value: xu.forecast.forecastday[0].astro.sunset, descriptionText: "Sunset today at is $localSunset", isStateChange: true)
    sendEvent(name: "xulocalSunrise", value: xu.forecast.forecastday[0].astro.sunrise, descriptionText: "Sunrise today at is $localSunrise", isStateChange: true)
    sendEvent(name: "xutemp_c", value: xu.current.temp_c, unit: "C", isStateChange: true)
    sendEvent(name: "xutemp_f", value: xu.current.temp_f, unit: "F", isStateChange: true)
    sendEvent(name: "xutemp", value: (isFahrenheit ? xu.current.temp_f : xu.current.temp_c), unit: "${(isFahrenheit ? 'F' : 'C')}", isStateChange: true)
    sendEvent(name: "xuis_day", value: xu.current.is_day, isStateChange: true)
    sendEvent(name: "xucondition_text", value: xu.current.condition.text, isStateChange: true)
    sendEvent(name: "xucondition_code", value: xu.current.condition.code, isStateChange: true)
    sendEvent(name: "xucondition_icon", value: 'http:' + xu.current.condition.icon, isStateChange: true)
    sendEvent(name: "xucondition_icon_only", value: xu.current.condition.icon.split("/")[-1], isStateChange: true)
    sendEvent(name: "xuforecastCondition_text", value: xu.forecast.forecastday[0].day.condition.text, isStateChange: true)            
    sendEvent(name: "xuforecast_code", value: xu.forecast.forecastday[0].day.condition.code, isStateChange: true)
    sendEvent(name: "xuforecast_icon", value: 'http:' + xu.forecast.forecastday[0].day.condition.icon, isStateChange: true)
    sendEvent(name: "xuforecast_icon_only", value: xu.forecast.forecastday[0].day.condition.icon.split("/")[-1], isStateChange: true)
    sendEvent(name: "xuwind_mph", value: xu.current.wind_mph, unit: "MPH", isStateChange: true)
    sendEvent(name: "xuwind_kph", value: xu.current.wind_kph, unit: "KPH", isStateChange: true)
    sendEvent(name: "xuwind", value: (isDistanceMetric ? xu.current.temp_c : xu.current.temp_f), unit: "${(isDistanceMetric ? 'kph' : 'mph')}", isStateChange: true)
    sendEvent(name: "xuwind_degree", value: xu.current.wind_degree, unit: "DEGREE", isStateChange: true)
    sendEvent(name: "xuwind_dir", value: xu.current.wind_dir, isStateChange: true)
    sendEvent(name: "xupressure_mb", value: xu.current.pressure_mb, unit: "MBAR", isStateChange: true)
    sendEvent(name: "xupressure_in", value: xu.current.pressure_in, unit: "IN", isStateChange: true)
    sendEvent(name: "xupressure", value: (isPressureMetric ? xu.current.pressure_mb : xu.current.pressure_in), unit: "${(isPressureMetric ? 'mb' : 'in')}", isStateChange: true)
    sendEvent(name: "xuprecip_mm", value: xu.current.precip_mm, unit: "MM", isStateChange: true)
    sendEvent(name: "xuprecip_in", value: xu.current.precip_in, unit: "IN", isStateChange: true)
    sendEvent(name: "xuprecip", value: (isRainMetric ? xu.current.precip_mm : xu.current.precip_in), unit: "${(isRainMetric ? 'mm' : 'in')}", isStateChange: true)
    sendEvent(name: "xuhumidity", value: xu.current.humidity, unit: "%", isStateChange: true)
    sendEvent(name: "xucloud", value: xu.current.cloud, unit: "%", isStateChange: true)
    sendEvent(name: "xufeelslike_c", value: xu.current.feelslike_c, unit: "C", isStateChange: true)
    sendEvent(name: "xufeelslike_f", value: xu.current.feelslike_f, unit: "F", isStateChange: true)
    sendEvent(name: "xufeelslike", value: (isFahrenheit ? xu.current.feelslike_f : xu.current.feelslike_c), unit: "${(isFahrenheit ? 'F' : 'C')}", isStateChange: true)
    sendEvent(name: "xuvis_km", value: xu.current.vis_km, unit: "KM", isStateChange: true)
    sendEvent(name: "xuvis_miles", value: xu.current.vis_miles, unit: "MILES", isStateChange: true)
    sendEvent(name: "xuvis", value: (isDistanceMetric ? xu.current.vis_km : xu.current.vis_miles), unit: "${(isDistanceMetric ? 'KM' : 'MILES')}", isStateChange: true)
    sendEvent(name: "xuUV", value: xu.forecast.forecastday[0].day.uv, isStateChange: true)
    sendEvent(name: "xuforecastConditions", value: xu.forecast.forecastday[0].day.condition.text, isStateChange: true)
    sendEvent(name: "xurainTomorrow_in", value: xu.forecast.forecastday[1].day.totalprecip_in, isStateChange: true)
    sendEvent(name: "xurainTomorrow_mm", value: xu.forecast.forecastday[1].day.totalprecip_mm, unit: "MM", isStateChange: true)
    sendEvent(name: "xurainTomorrow", value: (isRainMetric ? xu.forecast.forecastday[1].day.totalprecip_mm : xu.forecast.forecastday[1].day.totalprecip_in), unit: "${(isRainMetric ? 'mm' : 'in')}")
    sendEvent(name: "xurainDayAfterTomorrow_in", value: xu.forecast.forecastday[2].day.totalprecip_in, unit: "In", isStateChange: true)
    sendEvent(name: "xurainDayAfterTomorrow_mm", value: xu.forecast.forecastday[2].day.totalprecip_mm, unit: "MM", isStateChange: true)
    sendEvent(name: "xurainDayAfterTomorrow", value: (isRainMetric ? xu.forecast.forecastday[2].day.totalprecip_mm : xu.forecast.forecastday[2].day.totalprecip_in), unit: "${(isRainMetric ? 'mm' : 'in')}")
    sendEvent(name: "xuforecastHigh_c", value: xu.forecast.forecastday[0].day.maxtemp_c, unit: "C", isStateChange: true)
    sendEvent(name: "xuforecastHigh_f", value: xu.forecast.forecastday[0].day.maxtemp_f, unit: "F", isStateChange: true)
    sendEvent(name: "xuforecastHigh", value: (isFahrenheit ? xu.forecast.forecastday[0].day.maxtemp_f : xu.forecast.forecastday[0].day.maxtemp_c), unit: "${(isFahrenheit ? 'F' : 'C')}")
    sendEvent(name: "xuforecastLow_c", value: xu.forecast.forecastday[0].day.mintemp_c, unit: "C", isStateChange: true)
    sendEvent(name: "xuforecastLow_f", value: xu.forecast.forecastday[0].day.mintemp_f, unit: "F", isStateChange: true)
    sendEvent(name: "xuforecastLow", value: (isFahrenheit ? xu.forecast.forecastday[0].day.mintemp_f : xu.forecast.forecastday[0].day.mintemp_c), unit: "${(isFahrenheit ? 'F' : 'C')}")
    sendEvent(name: "xuwind_string_mi", value: "Wind is from " + xu.current.wind_dir + " at " + xu.current.wind_mph + " MPH", isStateChange: true)
    sendEvent(name: "xuwind_string_km", value: "Wind is from " + xu.current.wind_dir + " at " + xu.current.wind_kmh + " KPH", isStateChange: true)
    sendEvent(name: "xuwind_string", value: (isDistanceMetric ? "Wind is from " + xu.current.wind_dir + " at " + xu.current.wind_kmh + " KPH" : "Wind is from " + xu.current.wind_dir + " at " + xu.current.wind_mph + " MPH"))
    
    def lux = estimateLux(localTime, sunriseTime, sunsetTime, noonTime, twilight_begin, twilight_end, xu.current.condition.text, xu.current.cloud, xu.location.tz_id)
    sendEvent(name: "xuilluminance", value: lux)
    sendEvent(name: "xulux", value: String.format("%,d", lux))

    def wdnow = new Date().format('MM-dd-yyyy h:mm a', location.timeZone)
    sendEvent(name: "lastWDupdate", value: wdnow)

	sendEvent(name: "wdcity", value: wd.station.name.split(/ /)[0], isStateChange: true)
	sendEvent(name: "wdstate", value: wd.station.name.split(/ /)[1], isStateChange: true)
	sendEvent(name: "wdlocation", value: wd.station.name.split(/ /)[0] + ", " + wd.station.name.split(/ /)[1], isStateChange: true)
	sendEvent(name: "wdcountry", value: wd.station.name.split(/ /)[2], isStateChange: true)
	sendEvent(name: "wdlat", value: wd.station.latitude, isStateChange: true)
	sendEvent(name: "wdlon", value: wd.station.longitude, isStateChange: true)
	sendEvent(name: "wdlocal_time", value: Date.parse("HH:mm", wd.time.time).format("h:mm a"), isStateChange: true)
	sendEvent(name: "wdlocal_date", value: Date.parse("d/M/yyyy", wd.time.date).format("MM/dd/yyyy"))
	sendEvent(name: "wdFeelsLike_f", value: wd.everything.weather.apparent_temperature.current.f, isStateChange: true)
	sendEvent(name: "wdFeelsLike_c", value: wd.everything.weather.apparent_temperature.current.c, isStateChange: true)
	sendEvent(name: "wdFeelsLike", value: (isFahrenheit ? wd.everything.weather.apparent_temperature.current.f : wd.everything.weather.apparent_temperature.current.c), unit: "${(isFahrenheit ? 'F' : 'C')}")
	sendEvent(name: "wdweatherIcon", value: wd.everything.forecast.icon.code, isStateChange: true)
	sendEvent(name: "wdlocalSunset", value: wd.everything.astronomy.sun.sunset_time.hour + ":" + wd.everything.astronomy.sun.sunset_time.minute, descriptionText: "Sunset today at is $localSunset", isStateChange: true)
	sendEvent(name: "wdlocalSunrise", value: wd.everything.astronomy.sun.sunrise_time.hour + ":" + wd.everything.astronomy.sun.sunrise_time.minute, descriptionText: "Sunrise today is at $localSunrise", isStateChange: true)
	sendEvent(name: "wdmoonAge", value: wd.everything.astronomy.moon.moon_age.toDouble(), isStateChange: true)
			if (wd.everything.astronomy.moon.moon_age.toDouble() >= 0 && wd.everything.astronomy.moon.moon_age.toDouble() < 4) {sendEvent(name: "wdmoonPhase", value: "New Moon", isStateChange: true)}
			if (wd.everything.astronomy.moon.moon_age.toDouble() >= 4 && wd.everything.astronomy.moon.moon_age.toDouble() < 7) {sendEvent(name: "wdmoonPhase", value: "Waxing Crescent", isStateChange: true)}
			if (wd.everything.astronomy.moon.moon_age.toDouble() >= 7 && wd.everything.astronomy.moon.moon_age.toDouble() < 10) {sendEvent(name: "wdmoonPhase", value: "First Quarter", isStateChange: true)}
			if (wd.everything.astronomy.moon.moon_age.toDouble() >= 10 && wd.everything.astronomy.moon.moon_age.toDouble() < 14) {sendEvent(name: "wdmoonPhase", value: "Waxing Gibbous", isStateChange: true)}
			if (wd.everything.astronomy.moon.moon_age.toDouble() >= 14 && wd.everything.astronomy.moon.moon_age.toDouble() < 18) {sendEvent(name: "wdmoonPhase", value: "Full Moon", isStateChange: true)}
			if (wd.everything.astronomy.moon.moon_age.toDouble() >= 18 && wd.everything.astronomy.moon.moon_age.toDouble() < 22) {sendEvent(name: "wdmoonPhase", value: "Waning Gibbous", isStateChange: true)}
			if (wd.everything.astronomy.moon.moon_age.toDouble() >= 22 && wd.everything.astronomy.moon.moon_age.toDouble() < 26) {sendEvent(name: "wdmoonPhase", value: "Last Quarter", isStateChange: true)}
			if (wd.everything.astronomy.moon.moon_age.toDouble() >= 26) {sendEvent(name: "wdmoonPhase", value: "Waxing Gibbous", isStateChange: true)}
	sendEvent(name: "wdmoonIllumination", value: wd.everything.astronomy.moon.moon_phase + "%", isStateChange: true)
	sendEvent(name: "wdilluminance", value: wd.everything.weather.solar.irradiance.wm2, unit: "lux", isStateChange: true)
	sendEvent(name: "wdsolarradiation", value: wd.everything.weather.solar.irradiance.wm2, unit: "wm2", isStateChange: true)
	sendEvent(name: "wdUV", value: wd.everything.weather.uv.uvi, isStateChange: true)
	sendEvent(name: "wdforecastConditions", value: wd.everything.forecast.davis_forecast, isStateChange: true)
	sendEvent(name: "wdhumidity", value: wd.everything.weather.humidity.current, isStateChange: true)
	sendEvent(name: "wdforecastIcon", value: wd.everything.forecast.icon.code, isStateChange: true)
	sendEvent(name: "wdobservation_time", value: "Last updated on "  + Date.parse("d/M/yyyy", wd.time.date).format("MMMM d,") + " " + Date.parse("hh:mm", wd.time.time).format("h:mm a"), isStateChange: true)
	sendEvent(name: "wdwind_dir", value: wd.everything.weather.wind.direction.cardinal, isStateChange: true)
	sendEvent(name: "wdwind_degree", value: wd.everything.weather.wind.direction.degrees, isStateChange: true)
	sendEvent(name: "wdprecip_today_in", value: wd.everything.weather.rainfall.daily.in, unit: "IN", isStateChange: true)
	sendEvent(name: "wdprecip_today_mm", value: wd.everything.weather.rainfall.daily.mm, unit: "MM", isStateChange: true)
	sendEvent(name: "wdprecip_today", value: (isRainMetric ? wd.everything.weather.rainfall.daily.mm : wd.everything.weather.rainfall.daily.in), unit: "${(isRainMetric ? 'MM' : 'IN')}")
	sendEvent(name: "wddewpoint_c", value: wd.everything.weather.dew_point.current.c, unit: "C", isStateChange: true)
	sendEvent(name: "wddewpoint_f", value: wd.everything.weather.dew_point.current.f, unit: "F", isStateChange: true)
	sendEvent(name: "wddewpoint", value: (isFahrenheit ? wd.everything.weather.dew_point.current.f : wd.everything.weather.dew_point.current.f), unit: "${(isFahrenheit ? 'F' : 'C')}")
	sendEvent(name: "wdtemperature_c", value: wd.everything.weather.temperature.current.c, unit: "C", isStateChange: true)   	
	sendEvent(name: "wdtemperature_F", value: wd.everything.weather.temperature.current.f, unit: "F", isStateChange: true)    	
	sendEvent(name: "wdtemperature", value: (isFahrenheit ? wd.everything.weather.temperature.current.f : wd.everything.weather.temperature.current.c), unit: "${(isFahrenheit ? 'F' : 'C')}")	
	sendEvent(name: "wdwind_kph", value: wd.everything.weather.wind.max_gust_speed.kmh, unit: "KPH", isStateChange: true)  
	sendEvent(name: "wdwind_mph", value: wd.everything.weather.wind.avg_speed.mph, unit: "MPH", isStateChange: true)
	sendEvent(name: "wdwind", value: (isDistanceMetric ? wd.everything.weather.wind.max_gust_speed.kmh : wd.everything.weather.wind.max_gust_speed.mph), unit: "${(isDistanceMetric ? 'MPH' : 'KPH')}")
	sendEvent(name: "wdwind_gust_kph", value: wd.everything.weather.wind.max_gust_speed.kmh, isStateChange: true) 
	sendEvent(name: "wdwind_gust_mph", value: wd.everything.weather.wind.max_gust_speed.mph, isStateChange: true) 
	sendEvent(name: "wdwind_gust", value: (isDistanceMetric ? wd.everything.weather.wind.max_gust_speed.kmh : wd.everything.weather.wind.max_gust_speed.mph), unit: "${(isDistanceMetric ? 'MPH' : 'KPH')}")
	sendEvent(name: "wdpressure_mb", value: wd.everything.weather.pressure.current.mb, unit: "mb", isStateChange: true)
	sendEvent(name: "wdpressure_in", value: wd.everything.weather.pressure.current.inhg, unit: "inhg", isStateChange: true)
	sendEvent(name: "wdpressure", value: (isPressureMetric ? wd.everything.weather.pressure.current.mb : wd.everything.weather.pressure.current.inhg), unit: "${(isDistanceMetric ? 'In' : 'MB')}")

	if(sourcecity){
		sendEvent(name: "city", value: wd.station.name.split(/ /)[0], isStateChange: true)
        sendEvent(name: "state", value: wd.station.name.split(/ /)[1], isStateChange: true)
        sendEvent(name: "location", value: wd.station.name.split(/ /)[0] + ", " + wd.station.name.split(/ /)[1], isStateChange: true)
        sendEvent(name: "country", value: wd.station.name.split(/ /)[2], isStateChange: true)
        sendEvent(name: "lat", value: wd.station.latitude, isStateChange: true)
		sendEvent(name: "lon", value: wd.station.longitude, isStateChange: true)
		sendEvent(name: "local_time", value: Date.parse("HH:mm", wd.time.time).format("h:mm a"), isStateChange: true)
		sendEvent(name: "local_date", value: Date.parse("d/M/yyyy", wd.time.date).format("MM/dd/yyyy"))
	} else {
		sendEvent(name: "city", value: xu.location.name, isStateChange: true)
        sendEvent(name: "state", value: xu.location.region)
        sendEvent(name: "location", value: xu.location.name + ", " + xu.location.region, isStateChange: true)
        sendEvent(name: "country", value: xu.location.country, isStateChange: true)
        sendEvent(name: "lat", value: xu.location.lat, isStateChange: true)
    	sendEvent(name: "lon", value: xu.location.lon, isStateChange: true)
    	sendEvent(name: "local_time", value: localTimeOnly, isStateChange: true)
    	sendEvent(name: "local_date", value: localDate, isStateChange: true)
    	sendEvent(name: "last_updated", value: xu.current.last_updated, isStateChange: true)
	}		
	if(sourcefeelsLike){
		sendEvent(name: "feelsLike", value: wd.everything.weather.apparent_temperature.current.f, isStateChange: true)
        sendEvent(name: "forecastConditions", value: wd.everything.forecast.davis_forecast, isStateChange: true)
	} else {
		sendEvent(name: "feelsLike", value: xu.current.feelslike_f, unit: "F", isStateChange: true)
        sendEvent(name: "forecastConditions", value: xu.forecast.forecastday[0].day.condition.text, isStateChange: true)
	}
	if(sourceicon){
		sendEvent(name: "weatherIcon", value: wd.everything.forecast.icon.code, isStateChange: true)
	} else {
		if(iconType == false){   
			sendEvent(name: "weatherIcon", value: "http:" + xu.forecast.forecastday[0].day.condition.icon, isStateChange: true)
		}
		if(iconType == true){ 
			sendEvent(name: "weatherIcon", value: xu.current.condition.icon, isStateChange: true)
		}
	}
	if(sourcelocalSunset){
		sendEvent(name: "localSunset", value: wd.everything.astronomy.sun.sunset_time.hour + ":" + wd.everything.astronomy.sun.sunset_time.minute, descriptionText: "Sunset today at is $localSunset", isStateChange: true)
	} else {
		sendEvent(name: "localSunset", value: xu.forecast.forecastday[0].astro.sunset, descriptionText: "Sunset today at is $localSunset", isStateChange: true)
	}
	if(sourcelocalSunrise){
		sendEvent(name: "localSunrise", value: wd.everything.astronomy.sun.sunrise_time.hour + ":" + wd.everything.astronomy.sun.sunrise_time.minute, descriptionText: "Sunrise today is at $localSunrise", isStateChange: true)
	} else {
		sendEvent(name: "localSunrise", value: xu.forecast.forecastday[0].astro.sunrise, descriptionText: "Sunrise today is at $localSunrise", isStateChange: true)
	}
    sendEvent(name: "moonAge", value: wd.everything.astronomy.moon.moon_age.toDouble(), isStateChange: true)
    if (wd.everything.astronomy.moon.moon_age.toDouble() >= 0 && wd.everything.astronomy.moon.moon_age.toDouble() < 4) {sendEvent(name: "moonPhase", value: "New Moon", isStateChange: true)}
    if (wd.everything.astronomy.moon.moon_age.toDouble() >= 4 && wd.everything.astronomy.moon.moon_age.toDouble() < 7) {sendEvent(name: "moonPhase", value: "Waxing Crescent", isStateChange: true)}
    if (wd.everything.astronomy.moon.moon_age.toDouble() >= 7 && wd.everything.astronomy.moon.moon_age.toDouble() < 10) {sendEvent(name: "moonPhase", value: "First Quarter", isStateChange: true)}
    if (wd.everything.astronomy.moon.moon_age.toDouble() >= 10 && wd.everything.astronomy.moon.moon_age.toDouble() < 14) {sendEvent(name: "moonPhase", value: "Waxing Gibbous", isStateChange: true)}
    if (wd.everything.astronomy.moon.moon_age.toDouble() >= 14 && wd.everything.astronomy.moon.moon_age.toDouble() < 18) {sendEvent(name: "moonPhase", value: "Full Moon", isStateChange: true)}
    if (wd.everything.astronomy.moon.moon_age.toDouble() >= 18 && wd.everything.astronomy.moon.moon_age.toDouble() < 22) {sendEvent(name: "moonPhase", value: "Waning Gibbous", isStateChange: true)}
    if (wd.everything.astronomy.moon.moon_age.toDouble() >= 22 && wd.everything.astronomy.moon.moon_age.toDouble() < 26) {sendEvent(name: "moonPhase", value: "Last Quarter", isStateChange: true)}
    if (wd.everything.astronomy.moon.moon_age.toDouble() >= 26) {sendEvent(name: "moonPhase", value: "Waxing Gibbous", isStateChange: true)}
    sendEvent(name: "moonIllumination", value: wd.everything.astronomy.moon.moon_phase + "%", isStateChange: true)
	if(sourceIllumination){
		sendEvent(name: "illuminance", value: wd.everything.weather.solar.irradiance.wm2, unit: "lux", isStateChange: true)
        	sendEvent(name: "solarradiation", value: wd.everything.weather.solar.irradiance.wm2, unit: "wm2", isStateChange: true)
	} else {
		sendEvent(name: "illuminance", value: String.format("%,d", alux))
		sendEvent(name: "solarradiation", value: "This station does not send Solar Radiation data", isStateChange: true)
    }
	if(sourceUV){
		sendEvent(name: "UV", value: wd.everything.weather.uv.uvi, isStateChange: true)
	} else {
		sendEvent(name: "UV", value: xu.forecast.forecastday[0].day.uv, isStateChange: true)
	}
    sendEvent(name: "humidity", value: wd.everything.weather.humidity.current, isStateChange: true)
	sendEvent(name: "wind_dir", value: wd.everything.weather.wind.direction.cardinal, isStateChange: true)
	sendEvent(name: "wind_degree", value: wd.everything.weather.wind.direction.degrees, isStateChange: true)
	sendEvent(name: "precip_today", value: (isRainMetric ? wd.everything.weather.rainfall.daily.mm : wd.everything.weather.rainfall.daily.in), unit: "${(isRainMetric ? 'MM' : 'IN')}")
	sendEvent(name: "dewpoint", value: (isFahrenheit ? wd.everything.weather.dew_point.current.f : wd.everything.weather.dew_point.current.f), unit: "${(isFahrenheit ? 'F' : 'C')}")
	sendEvent(name: "temperature", value: (isFahrenheit ? wd.everything.weather.temperature.current.f : wd.everything.weather.temperature.current.c), unit: "${(isFahrenheit ? 'F' : 'C')}")	
	sendEvent(name: "wind", value: (isDistanceMetric ? wd.everything.weather.wind.max_gust_speed.kmh : wd.everything.weather.wind.max_gust_speed.mph), unit: "${(isDistanceMetric ? 'MPH' : 'KPH')}")
	sendEvent(name: "wind_gust", value: (isDistanceMetric ? wd.everything.weather.wind.max_gust_speed.kmh : wd.everything.weather.wind.max_gust_speed.mph), unit: "${(isDistanceMetric ? 'MPH' : 'KPH')}")
	sendEvent(name: "pressure", value: (isPressureMetric ? wd.everything.weather.pressure.current.mb : wd.everything.weather.pressure.current.inhg), unit: "${(isDistanceMetric ? 'In' : 'MB')}")
    sendEvent(name: "vis", value: (isDistanceMetric ? xu.current.vis_km : xu.current.vis_miles), unit: "${(isDistanceMetric ? 'KM' : 'MILES')}", isStateChange: true)
    sendEvent(name: "rainTomorrow", value: (isRainMetric ? xu.forecast.forecastday[1].day.totalprecip_mm : xu.forecast.forecastday[1].day.totalprecip_in), unit: "${(isRainMetric ? 'mm' : 'in')}")
    sendEvent(name: "rainDayAfterTomorrow", value: (isRainMetric ? xu.forecast.forecastday[2].day.totalprecip_mm : xu.forecast.forecastday[2].day.totalprecip_in), unit: "${(isRainMetric ? 'mm' : 'in')}")
    sendEvent(name: "forecastHigh", value: (isFahrenheit ? xu.forecast.forecastday[0].day.maxtemp_f : xu.forecast.forecastday[0].day.maxtemp_c), unit: "${(isFahrenheit ? 'F' : 'C')}")
    sendEvent(name: "forecastLow", value: (isFahrenheit ? xu.forecast.forecastday[0].day.mintemp_f : xu.forecast.forecastday[0].day.mintemp_c), unit: "${(isFahrenheit ? 'F' : 'C')}")
    sendEvent(name: "wind_string", value: (isDistanceMetric ? "Wind is from " + xu.current.wind_dir + " at " + xu.current.wind_kmh + " KPH" : "Wind is from " + xu.current.wind_dir + " at " + xu.current.wind_mph + " MPH"))
    
    if(summaryType == true){
		if (weatherFormat == "Celsius, Miles & MPH"){
			sendEvent(name: "weatherSummary", value: "Weather summary for" + " " + wd.station.name.split(/ /)[0] + ", " + wd.station.name.split(/ /)[1] 
			+ " updated at " + Date.parse("HH:mm", wd.time.time).format("h:mm a") + " on " + Date.parse("d/M/yyyy", wd.time.date).format("MMMM d") + ". "  
			+ xu.forecast.forecastday[0].day.condition.text + " with a high of " + xu.forecast.forecastday[0].day.maxtemp_c + " degrees, " + "and a low of " 
			+ xu.forecast.forecastday[0].day.mintemp_c  + " degrees. " + "Humidity is currently around " + wd.everything.weather.humidity.current + "% and temperature is " 
			+ wd.everything.weather.temperature.current.c + " degrees. " + " The temperature feels like it's " + xu.current.feelslike_c + " degrees. " 
			+ "Wind is from the " + wd.everything.weather.wind.direction.cardinal
			+ " at " + wd.everything.weather.wind.avg_speed.mph + " mph" + ", with gusts up to " + wd.everything.weather.wind.max_gust_speed.mph + " mph" + ". Visibility is around " 
			+ xu.current.vis_miles + " miles." , isStateChange: true
			)  
		}
		if (weatherFormat == "Fahrenheit, Miles & MPH"){
			sendEvent(name: "weatherSummary", value: "Weather summary for " + wd.station.name.split(/ /)[0] + ", " + wd.station.name.split(/ /)[1] 
			+ " updated at " + Date.parse("HH:mm", wd.time.time).format("h:mm a") + " on " + Date.parse("d/M/yyyy", wd.time.date).format("MMMM d") + ". "  
			+ xu.forecast.forecastday[0].day.condition.text + " with a high of " + xu.forecast.forecastday[0].day.maxtemp_f + " degrees, " + "and a low of " 
			+ xu.forecast.forecastday[0].day.mintemp_f  + " degrees. " + "Humidity is currently around " + wd.everything.weather.humidity.current + "% and temperature is " 
			+ wd.everything.weather.temperature.current.f + " degrees. " + " The temperature feels like it's " + xu.current.feelslike_f + " degrees. " 
			+ "Wind is from the " + wd.everything.weather.wind.direction.cardinal
			+ " at " + wd.everything.weather.wind.avg_speed.mph + " mph" + ", with gusts up to " + wd.everything.weather.wind.max_gust_speed.mph + " mph" + ". Visibility is around " 
			+ xu.current.vis_miles + " miles." , isStateChange: true
			)
		}   
		 if (weatherFormat == "Celsius, Kilometres & KPH"){
			sendEvent(name: "weatherSummary", value: "Weather summary for" + " " + wd.station.name.split(/ /)[0] + ", " + wd.station.name.split(/ /)[1] 
			+ " updated at " + Date.parse("HH:mm", wd.time.time).format("h:mm a") + " on " + Date.parse("d/M/yyyy", wd.time.date).format("MMMM d") + ". "  
			+ xu.forecast.forecastday[0].day.condition.text + " with a high of " + xu.forecast.forecastday[0].day.maxtemp_c + " degrees, " + "and a low of " 
			+ xu.forecast.forecastday[0].day.mintemp_c  + " degrees. " + "Humidity is currently around " + wd.everything.weather.humidity.current + "% and temperature is " 
			+ wd.everything.weather.temperature.current.c + " degrees. " + " The temperature feels like it's " + xu.current.feelslike_c + " degrees. " 
			+ "Wind is from the " + wd.everything.weather.wind.direction.cardinal
			+ " at " + wd.everything.weather.wind.avg_speed.kmh + " kph" + ", with gusts up to " + wd.everything.weather.wind.max_gust_speed.kmh + " kph" + ". Visibility is around " 
			+ xu.current.vis_km + " kilometers." , isStateChange: true
			)  
		}                
	}    
	if(summaryType == false){
		if (weatherFormat == "Celsius, Miles & MPH"){
			sendEvent(name: "weatherSummary", value: wd.everything.forecast.davis_forecast + ". " + " Today's High:" + wd.everything.weather.temperature.current.high.c + ", Today's Low:" 
			+ wd.everything.weather.tempurature.current.low.c  +  ". Humidity: " + wd.everything.weather.current.humidity + "% Temperature: " 
			+ wd.everything.weather.tempurature.current.c  + ". Wind Direction: " + wd.everything.weather.wind.direction.cardinal + ". Wind Speed: " + wd.everything.weather.avg_speed.mph + " mph" 
			+ ", Gust: " + wd.everything.weather.max_gust_speed.mph + " mph.", isStateChange: true
			)  
		}
		if (weatherFormat == "Fahrenheit, Miles & MPH"){
			sendEvent(name: "weatherSummary", value: wd.everything.forecast.davis_forecast + ". " + " Today's High:" + wd.everything.weather.temperature.current.high.f + ", Today's Low:" 
			+ wd.everything.weather.tempurature.current.low.f  +  ". Humidity: " + wd.everything.weather.current.humidity + "% Temperature: " 
			+ wd.everything.weather.tempurature.current.f  + ". Wind Direction: " + wd.everything.weather.wind.direction.cardinal + ". Wind Speed: " + wd.everything.weather.avg_speed.mph + " mph" 
			+ ", Gust: " + wd.everything.weather.max_gust_speed.mph + " mph.", isStateChange: true
			)  
		}
		 if (weatherFormat ==  "Celsius, Kilometres & KPH"){
			sendEvent(name: "weatherSummary", value: wd.everything.forecast.davis_forecast + ". " + " Today's High:" + wd.everything.weather.temperature.current.high.c + ", Today's Low:" 
			+ wd.everything.weather.tempurature.current.low.c  +  ". Humidity: " + wd.everything.weather.current.humidity + "% Temperature: " 
			+ wd.everything.weather.tempurature.current.c  + ". Wind Direction: " + wd.everything.weather.wind.direction.cardinal + ". Wind Speed: " + wd.everything.weather.avg_speed.kmh + " kph" 
			+ ", Gust: " + wd.everything.weather.max_gust_speed.kmh + " kph.", isStateChange: true
			)  
		}
	}
    return 
}

private getXUdata()   {
    def xu = [:]
    def params = [ uri: "https://api.apixu.com/v1/forecast.json?key=$xuapiKey&q=$xupollLocation&days=3" ]
    try {
        httpGet(params)		{ resp -> xu << resp.data }
    } catch (e) { log.error "http call failed for APIXU weather api: $e" }
        
    if(xulogSet == true){  
        log.debug "params: ${params}"       
        log.debug "response data: ${xu}"
    } 
    if(wulogSet == false){ 
        log.info "Further APIXU data logging disabled"    
    }    
    
    return xu
}

private getWDdata()   {
    def wd = [:]
    def params = [ uri: "${wdpollLocation}everything.php" ]
    try {
        httpGet(params)		{ resp -> wd << resp.data }
    } catch (e) { log.error "http call failed for Weather-Display weather api: $e" }

    if(wdlogSet == true){  
        log.debug "params: ${params}"       
        log.debug "response data: ${wd}"
    } 
    if(wdlogSet == false){ 
        log.info "Further Weather-Display data logging disabled"    
    }        
    return wd
}
def refresh()       { poll() }

def configure()     { poll() }

private getSunriseAndSunset(latitude, longitude, forDate)	{
/*    log.debug "lat: $latitude"
    log.debug "lon: $longitude"
    log.debug "forDate: $forDate"
*/
    def params = [ uri: "https://api.sunrise-sunset.org/json?lat=$latitude&lng=$longitude&date=$forDate&formatted=0" ]
    def sunRiseAndSet = [:]
    try {
        httpGet(params)		{ resp -> sunRiseAndSet = resp.data }
    } catch (e) { log.error "http call failed for sunrise and sunset api: $e" }
    return sunRiseAndSet
}

private estimateLux(localTime, sunriseTime, sunsetTime, noonTime, twilight_begin, twilight_end, condition_text, cloud, tz_id)     {
/*    log.debug "localTime: $localTime"
    log.debug "twilight_begin: $twilight_begin"
    log.debug "sunriseTime: $sunriseTime"
    log.debug "noonTime: $noonTime"
    log.debug "sunsetTime: $sunsetTime"
    log.debug "twilight_end: $twilight_end"
    log.debug "condition_text: $condition_text"
    log.debug "cloud: $cloud"
    log.debug "tz_id: $tz_id"
*/
    def tZ = TimeZone.getTimeZone(tz_id)
    def lux = 0l
    def aFCC = true
    def l

    if (timeOfDayIsBetween(sunriseTime, noonTime, localTime, tZ))      {
        log.debug "between sunrise and noon"
        l = (((localTime.getTime() - sunriseTime.getTime()) * 10000f) / (noonTime.getTime() - sunriseTime.getTime()))
        lux = (l < 50f ? 50l : l.trunc(0) as long)
    }
    else if (timeOfDayIsBetween(noonTime, sunsetTime, localTime, tZ))      {
        log.debug "between noon and sunset"
        l = (((sunsetTime.getTime() - localTime.getTime()) * 10000f) / (sunsetTime.getTime() - noonTime.getTime()))
        lux = (l < 50f ? 50l : l.trunc(0) as long)
    }
    else if (timeOfDayIsBetween(twilight_begin, sunriseTime, localTime, tZ))      {
        log.debug "between sunrise and twilight"
        l = (((localTime.getTime() - twilight_begin.getTime()) * 50f) / (sunriseTime.getTime() - twilight_begin.getTime()))
        lux = (l < 10f ? 10l : l.trunc(0) as long)
    }
    else if (timeOfDayIsBetween(sunsetTime, twilight_end, localTime, tZ))      {
        log.debug "between sunset and twilight"
        l = (((twilight_end.getTime() - localTime.getTime()) * 50f) / (twilight_end.getTime() - sunsetTime.getTime()))
        lux = (l < 10f ? 10l : l.trunc(0) as long)
    }
    else if (!timeOfDayIsBetween(twilight_begin, twilight_end, localTime, tZ))      {
        log.debug "between non-twilight"
        lux = 5l
        aFCC = false
    }
    
    if (aFCC)       lux = ((lux * (100l - (cloud.toInteger() / 3l))) / 100l) as long;
    return lux
}

private timeOfDayIsBetween(fromDate, toDate, checkDate, timeZone)     {
    return (!checkDate.before(fromDate) && !checkDate.after(toDate))
}
